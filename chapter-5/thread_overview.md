# 线程概述

这一章的前言可能有点难以理解，所以在这篇概述里我们再花点文字来介绍线程。可能截止目前，大家所编写的程序都是从main函数开始，然后一行行的执行代码直到main函数结束返回。整个程序的流程可以用简单的流程图绘制出来，即使有控制台输出输出的交互，也会等待用户输入之后进行下一步的操作。但是，在程序设计中，这种“一条道走到黑”的设计方法并不能覆盖完所有的需求场景。有时候我们需要让一个程序在执行的同时做一些事情，而不是做完了一件之后再做另外一件。

之前在进程创建那一章，可能你对Linux下的fork这个系统调用有了一些理解。在类Unix操作系统里的fork在其他操作系统里并不一定存在，比如在Windows操作系统里并没有类似fork这样的系统函数。Windows上创建新的进程的API函数是[CreateProcess](https://msdn.microsoft.com/en-us/library/ms682425.aspx)，这个名字简单易懂的API函数有大约10个参数，包括可执行的模块的路径和要传入的调用参数。**从某种意义上看，这个函数更像是Linux下fork+exec的结合体。**Linux下的fork函数调用后，父进程被克隆之后诞生了另外一个进程，从另外的代码入口开始执行。但是，进程间存在的操作系统的隔离特性使得父子进程对自身数据的修改仅对自己可见。也就是说，即使是看起来一样的全局变量，父子进程修改的仅仅是自己“私有”的那一份。如果父子进程需要交换数据，就需要通过进程间通信（IPC）的一些手段来进行数据交换了。

但是有的时候，要实现的程序逻辑是**创建一个“子任务”**，这个子任务执行的也是本程序的某些代码，但是共享程序内的某些变量。子任务可以随时被创建，也可以随时被结束，而且执行的数量也可以自由的控制。早期的操作系统中并没有这样的机制，当时的工程师门采用了各种各种的“黑魔法”在操作系统不支持的情况下实现了这一机制。**但是如果仅仅只是在用户态模拟出多个“执行流”，而操作系统层面上并没有给于支持的话，模拟出的多个执行流并不会真正并行的运行在多个处理器的核心上。因为在操作系统层面上看来，只是在一个CPU核心上运行着这个进程。 这个进程私下在自己若干个执行流之间不断的切换着，而这一切对操作系统是保密的，操作系统也无法调度干涉。**

后来随着操作系统不断的发展，逐渐就支持了这样的子任务机制，也提供了这样的系统调用来供应用程序创建子任务。这样的机制被取名为线程。如果你在别的资料上看到有诸如协程，纤程之类的名词，先别和这个混为一谈。当你对这个问题理解到一定程度，你会觉得协程不就是没有线程之前的那些黑魔法么。不好意思扯远了，我们回来。有意思的是，早期的Linux压根就没有线程这么个东西。后来顺应时代的潮流要支持这一机制的时候，就遇到了各种各样的麻烦。因为一开始就没有相关的设计，所以必然会导致操作系统的诸多模块需要进行大量的修改。Linux最终在这个地方采取了取巧的做法来支持线程。即创建的线程依旧是复制父进程的一些内核控制数据结构来创建子进程，但是同时让父子进程共享地址空间、文件系统资源、文件描述符、信号处理程序以及被阻断的信号等内容。这样实际上创建了一个“轻量级进程”，但是因为共享了很多资源，会在修改时修改同一份资源，而不是fork那种在写时复制创建新的资源后修改，所以也在一定程度上实现了线程这一需求。再后来内核还是经历了一些修改以更好的支持线程这一概念，但是作为概述我们就不能在这个问题上过度纠缠了。有兴趣的话本章节的扩展阅读中会讲述Linux线程的前世今生，有兴趣的话看看吧。

言归正传，Linux下创建线程的系统调用是clone，创建的参数和相关的参数比较抽象和难以理解。POSIX规范给出了线程标准函数接口的定义和相关的规则。Linux下的C语言标准库glibc的pthread部分实现了这一标准，这也是日常使用线程相关的服务所调用的相关函数。接下来的章节将逐渐展开，逐渐揭开Linux下线程函数的面纱，开始讲述Linux线程的创建与结束，同步与互斥。