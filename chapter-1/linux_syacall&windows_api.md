# Linux系统调用与Windows API

不知道看到标题的你有没有疑惑呢？左边是Linux系统调用，右边怎么是Windows API？为什么不都叫系统调用或者都叫API呢？其实Windows也有系统调用的，但是一般情况下我们使用的是Windows在系统调用之上的又一层代码的封装——Windows API.

那Windows API和Windows的系统调用是不是一对一的关系呢？不是的，Windows下有的API会直接调用某个系统调用，有的API会调用多个系统调用，有的API甚至不会调用系统调用（比如一些字符编码转换的API）。那你可能很好奇，为什么微软要做这样的封装呢？有一个原因是Windows是一个闭源的操作系统，其内部的实现机理在一定程度上是保密的。那么应用程序要实现某个功能，很大程度上要取决于Windows是否提供了相关的API函数来解决。另外，为了吸引诸多的Windows开发者，微软也会提供更多好用易用的API函数来简化应用程序的实现，而且会尽可能的让API稳定，易用和高效。

说了这么多，有Linux系统调用与Windows系统调用的详单吗？当然有的，戳这里——[Linux系统调用](http://syscalls.kernelgrok.com/)、[Windows 系统调用](http://j00ru.vexillium.org/ntapi/)。这里列出的Windows的系统调用，因为最新的Windows的API列表恐怕上万了（为了兼容，即使对API修改也必须引入新的API来解决）。从数量上看，Windows API貌似比Linux的系统调用多出若干倍啊，是不是Windows的功能更牛逼呢？当然不是啦，因为在Linux下，有很多功能可以通过相同的系统调用以不同的参数来解决，另外系统信息的获取更是抽象出了/proc这个虚拟的文件系统来使用相同的方式获取。什么？听不懂？没关系，读完这本书就懂了。

我原本想得是让大家尽可能的同时接触Linux和Windows，相互印证对比的去学习，从来理性的辨别不同操作系统的适应场合和企业/工程上的各项使用成本，从而合理的选择适合的操作系统。而不是偏激的认为Linux和开源就是一切，继而盲目的贬低其它的操作系统。所以呢，我会在讲述Linux系统的某些机制和原理的时候，主动的告诉大家Windows系统中相对存在的或者类似的事物。一方面大家对比着学习理解，另一方面也让大家知晓触类旁通的学习理念。那么，在后续章节的描述中，我会慢慢尝试按照自己的想法来尝试性的加入一点点对比和实验，希望会有不错的效果。
